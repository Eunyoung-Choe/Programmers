[ 문제 ]
'''
정수 배열 arr가 주어집니다. 
arr의 각 원소에 대해 값이 50보다 크거나 같은 짝수라면 2로 나누고, 50보다 작은 홀수라면 2를 곱하고 다시 1을 더합니다.
이러한 작업을 x번 반복한 결과인 배열을 arr(x)라고 표현했을 때, arr(x) = arr(x + 1)인 x가 항상 존재합니다. 
이러한 x 중 가장 작은 값을 return 하는 solution 함수를 완성해 주세요.
단, 두 배열에 대한 "="는 두 배열의 크기가 서로 같으며, 같은 인덱스의 원소가 각각 서로 같음을 의미합니다.
arr                    	  result
[1, 2, 3, 100, 99, 98]  	5
'''
//=====================================================================

[ 내 풀이 ]
// 레전드 모르겠어서 하루 종일 미루다 풂.....알고리즘 잘 보이면 좋겠다.
import java.util.*;
class Solution {
    public int solution(int[] arr) {
        int count = 0;
        int[] nowArr = Arrays.copyOf(arr, arr.length); // 현재 상태 배열 

        // 배열 2개를 정의해 현재 배열과 다음 배열이 같은지를 비교 (같으면 중단)
        while(true) {
            int[] newArr = new int[arr.length]; // 갱신되는 새로운 비교 대상 배열
            
            // 새로운 배열에 수식값 적용
            for(int i=0; i<arr.length; i++) {
                if(nowArr[i] >= 50)
                    newArr[i] = (nowArr[i] % 2 == 0) ? nowArr[i]/2 : nowArr[i];
                else if(nowArr[i] < 50)
                    newArr[i] = (nowArr[i] % 2 == 1) ? nowArr[i]*2+1 : nowArr[i];
            }
            
            if(Arrays.equals(nowArr, newArr)) break; // 현재-갱신 배열이 같으면 반복 중단
            
            // 배열이 서로 다르다면 현재 배열을 업데이트
            if(!Arrays.equals(nowArr, newArr))
                nowArr = Arrays.copyOf(newArr, newArr.length); // 이렇게 다시 담기가 가능
            
            count++;
        }
        return count;
    }
}
//=====================================================================

[ 타 풀이 ]
// 어떻게 이런 생각을 하지 부럽다......
// 원소 하나가 안정화(더 이상 바뀌지 않는 상태)를 각각 카운트 해서 그 중 가장 큰 값을 골라내는 방식
import java.util.Arrays;
class Solution {
    public int solution(int[] arr) {
        return Arrays.stream(arr).map(i -> cntAction(i)).max().getAsInt();
    }

    private int cntAction(int n) {

        int cnt = 0;
        boolean flag = true;

        while (flag) { // 원소가 바뀌었으면 false가 아니니까 반복 
            if (n % 2 == 0 && 50 <= n) {
                n /= 2;
                cnt++;
            } else if (n % 2 == 1 && n < 50) {
                n *= 2;
                n += 1;
                cnt++;
            } else {
                flag = false;
            }
        }
        return cnt;
    }
}
//=====================================================================

[ 메모 ]
1. 타 풀이에서 끝에 왜 getAsInt()를 썼을까? max()이면 이미 int를 뽑은 거 아닌가?
  이건 이전에 한 번 다루었던 OptionalInt에 대한 내용이다.

  .map(i -> cntAction(i)) // 이 시점의 반환형은 IntStream
  .max() // 그럼 IntStream.max()인 건데, 이 반환형이 int가 아니라 'OptionalInt'임!

  왜냐면 스트림이 비어있을 수도 있기 때문. arr이 빈 배열이면 max() 계산 불가능.
  따라서 '값이 있을수도 없을수도 있는 상황'을 Optional로 감싸서 표현하는 거고, 현재 Optional에 싸여 있으니 getAsInt()로 실제 값을 꺼내야 한다는 것.
  
  여전히 와닿지 않는다.
  Optional로 나오는 경우를 외워야 하는 건가?
  그래서 정리한 쉬운 이해!

  일반 Stream은 기본형을 다루지 못하므로 Arrays.stream(int[])처럼 기본형 배열을 처리하려면 IntStream 같은 전용 스트림을 써야 함.
  IntStream을 썼으니 결과가 int로 바로 나오지 못하겠지?
  그러니 마지막엔 getAsInt()로 int값로 만든다.


2. 참고로 Stream도 두 가지로 구분됨.
  코테에서 이제껏 자주 본 '기본형 스트림'(IntStream 등)과 '객체 스트림'(Stream<T>).


3. int[] 기본형 배열을 스트림화 할 땐 Arrays.stream()이 필요한 거야, IntStream이 필요한 거야?
  : 애초에 둘은 연결된 관계임. Arrays.stream()을 쓰면 담긴 값들에 따라 IntStream, LongStream, Stream<T> 등등이 반환됨.
  근데 IntStream.of(arr)라는 것도 있다고 함. Arrays.stream(arr)과 똑같은 기능이라고.
  그래도 Arrays.stream()이 가장 일반적!

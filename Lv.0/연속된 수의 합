[ 문제 ]
'''
연속된 세 개의 정수를 더해 12가 되는 경우는 3, 4, 5입니다. 
두 정수 num과 total이 주어집니다. 
연속된 수 num개를 더한 값이 total이 될 때, 정수 배열을 오름차순으로 담아 return하도록 solution함수를 완성해보세요.
num개의 연속된 수를 더하여 total이 될 수 없는 테스트 케이스는 없습니다.
num	total	result
3	  12	  [3, 4, 5]
5  	5	    [-1, 0, 1, 2, 3]
'''
//=====================================================================

[ 내 풀이 ]
// 수학식을 코드로 쓸래니 좀 안 떠올랐는데 한 방에 맞춰서 기분이 매우 좋슨^^
// a+a=2a를 코드에선 그냥 2*a로 표현하면 된다는 게 시간이 걸린...
class Solution {
    public int[] solution(int num, int total) {
        int sub = 0;
        
        for(int i=0; i<num; i++) { // 기준을 0부터 잡은 합
            sub += i;
        }
        
        int a = (total - sub) / num;  // a*num + b = total
        int[] answer = new int[num];
        
        for(int j=0; j<answer.length; j++) {
            answer[j] = a + j;
        }
        
        return answer;
    }
}
//=====================================================================

[ 타 풀이 ]
int[] answer = new int[num];
int check = num*(num+1) / 2;
int start = (total - check) / num + 1; // +1은 기준을 1부터 잡았기 때문..? 1 없애면 답안보다 수가 1씩 작게 나옴.

for (int i = 0; i < answer.length; i++) {
        answer[i] = start + i ;
}

return answer;
// check 식이 나오는 과정 (=내 풀이의 sub) (길게 썼지만 어쨌든 합 공식임.)
// : 연속된 num개의 정수는 x, x+1, x+2, … , x+(num-1) 이렇게 되고, 이걸 다 더하면 num*x + (0 + 1 + 2 + … + (num-1)) = total임.
// : 나온 식에서 일단 (0 + 1 + 2 + … + (num-1)만 봤을 때, 이 식의 값은 내가 모르는 상태.
//   But 현재 1 + 2 + 3 + … + num의 값은 알고 있으니 이거에 맞춰 식을 변형하면 되는 것.
     따라서 0 + 1 + 2 + … + (num-1)을 다르게 표현하면 (1 + 2 + … + num) - num이 되고(양변에서 num 빼기), 정리햐면 num*(num+1)/2 - num임.
//=====================================================================

[ 메모 ]
1. 아!!!!! 1시간 넘게 내 풀이 타 풀이 식 차이를 이해 못하다 알았다!!
  합 공식은 0 ~ (n-1)인지, 1 ~ n인지에 따라 공식이 달라진다...!
  전자 -> n(n-1)/2
  후자 -> n(n+1)/2

  나는 전자였고, 타 풀이는 1부터 시작하는 합 공식을 선택했기 때문에 +1 보정이 필요했던 것...!

[ 문제 ]
'''
정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.
각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 i가 k의 배수이면 arr[i]에 1을 더합니다.
위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.
arr            	  queries	                          result
[0, 1, 2, 4, 3] 	[[0, 4, 1],[0, 3, 2],[0, 3, 3]]	  [3, 2, 4, 6, 4]
'''
//=====================================================================

[ 내 풀이 ]
// 문제부터 이해가 가지 않아서 애먹음;;(나만 안 읽힌 게 아닌 듯) 그래도 한 번에 성공!!
class Solution {
    public int[] solution(int[] arr, int[][] queries) {
        // [s,e,k] 중 s,e로 i의 범위를 지정
        // i는 인덱스 값 아니고 말 그대로 s,e 사이의 모든 자연수(0,1,2,3...)
        // 0도 배수로 치고 있음.
        // [0,3,2]이면 0~3 수들 중 2의 배수인 건 0과 2뿐이니 arr[0], arr[2] 값만 증가시킴.
        
        for(int[] query : queries) {
        // i의 범위 = query[0], query[1]
        // i를 증가시켜 가면서 query[1]의 배수인지 확인
            for(int i=query[0]; i<=query[1]; i++)
            // i가 query[2]의 배수인지 확인
                if(i%query[2]==0) {
                    arr[i] += 1; // = arr[i]++
                }
        }
        return arr;
    }
}
//=====================================================================

[ 타 풀이 1 ]
for (int i = 0; i < queries.length; i++) {
    for (int j = queries[i][0]; j <= queries[i][1]; j++) {
        if (j % queries[i][2] == 0) arr[j] += 1;
    }
}
return arr;
// 이렇게 쓰니까 변동, 고정 부분이 눈에 잘 들어와서 가독성이 좋은 듯?
//=====================================================================

[ 메모 ]
1. 처음 for문 조건식 잘못 썼었음. for(int i; query[0]<=i<=query[2]; i++) 형태는 파이썬에서나 가능한 것.
  중첩 조건식이 안 되니까 i 디폴트값을 query[0]으로 잡아야 함.

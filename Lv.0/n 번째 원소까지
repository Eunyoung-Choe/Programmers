[ 문제 ]
'''
정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 n 번째 원소까지의 
모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.
'''
//=====================================================================

[ 내 풀이 ]
import java.util.stream.*;
class Solution {
    public int[] solution(int[] num_list, int n) {
//         int[] answer = new int[n];
        
//         for(int i=0; i<=n-1; i++) {
//             answer[i] = num_list[i];
//         }
        // return answer;
        
        return IntStream.range(0,n).map(i->num_list[i]).toArray(); // 나도 stream으로 풀어봤다.
    }
}
//=====================================================================

[ 타 풀이 1 ]
return Arrays.copyOfRange(num_list, 0, n); // 생각해보니 이것도 있었네.

[ 타 풀이 2 ]
import java.util.*;
class Solution { 
    public Integer[] solution(int[] numList, int n) { // 변환 타입을 바꿨음.
        return Arrays.stream(numList).boxed().limit(n).toArray(Integer[]::new);
    }
}
// .boxed(): 각 int를 Integer로 변환 (Stream<Integer>로 변환)
              toArray(Integer[]::new) 같은 건 객체 배열만 만들 수 있기 때문.
// .limit(n): 앞에서 n까지만 잘라냄.
// .toArray(Integer[]::new): 스트림을 배열로 변환 

[ 타 풀이 3 ]
// 위 2번 풀이 반환을 배열로만 바꾸면 아래와 같음.
return Arrays.stream(numList).limit(n).toArray();
//=====================================================================

[ 메모 ]
1. map(i->num_list[i]) 자체가 반복문인 게 아니고, 해당 범위의 정수를 생성해 각 인덱스르 원소로 치환하는 걸 반복함.

2. 타 풀이 2,3에서 둘다 toArray()를 썼는데 반환 타입은 다른 이유!
  • 타 풀이 2 -> boxed()를 쓰면 IntStream이 객체 스트림인 Stream<Integer>로 변환됨.
                즉, Stream<T>의 toArray()를 쓰게 되면서 Integer[]를 반환.
  • 타 풀이 3 -> 여기서의 stream은 IntStream임. IntStream.toArray()는 무조건 int[] 반환.

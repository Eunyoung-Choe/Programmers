[ 문제 ]
'''
음이 아닌 정수를 9로 나눈 나머지는 그 정수의 각 자리 숫자의 합을 9로 나눈 나머지와 같은 것이 알려져 있습니다.
이 사실을 이용하여 음이 아닌 정수가 문자열 number로 주어질 때, 
이 정수를 9로 나눈 나머지를 return 하는 solution 함수를 작성해주세요.
number	                 result
"123"	                   6
"78720646226947352489"	 2
'''
//=====================================================================

[ 내 풀이 ]
class Solution {
    public int solution(String number) {
        int answer = 0;
        
        for(int i=0; i<number.length(); i++) {
            // parseInt는 String을 입력으로 받음!
            answer += Integer.parseInt(String.valueOf(number.charAt(i)));
        }
        answer = answer % 9;
        return answer;
    }
}
//=====================================================================

[ 타 풀이 1 ]
return number.chars().map(c -> (c - '0') % 9).sum() % 9; // 유니코드 값을 알아야 이해되는 식
// map(c -> (c - '0') % 9) → [1, 2, 3] 이런 식이 됨.
// Stream이라서 sum() 쓸 수 있던 거임. Stream은 배열/리스트 데이터를 함수형으로 다루기 위한 객체.

[ 타 풀이 2 ]
int sum = 0;
for (char ch : number.toCharArray()) // 메서드 보기
    sum += ch - '0';

return sum % 9;
//=====================================================================

[ 메모 ]
1. String.valueOf()로 감싸지 않아 오류 났었음. 
  다른 타입을 문자열(String)로 바꿔주는 메서드로, int, char, boolean 다 String으로 바꿈.

2. .chars(): 문자열을 IntStream으로 바꿈.
  String number="123"
  number.chars(); // [49, 50, 51]  ('1','2','3'의 유니코드 값)

  char 타입은 아스키 코드값을 사용하여 문자를 저장함!
  타 풀이에서 '0'을 뺀 이유는 '0'의 유니코드가 48이라 c-'0'을 하면 진짜 숫자값이 나오기 때문.
  '1' - '0' = 1 (49-48=1)

3. 람다식->을 쓸 때 컴파일러가 타입을 추론할 수 있으면 굳이 타입을 안 써도 됨.
  원래라면 stream.map((int c) -> { return c - '0'; });

4. toCharArray(): 문자열을 하나씩 쪼갠 문자 배열로 바꿈.
  "123" → {'1', '2', '3'}

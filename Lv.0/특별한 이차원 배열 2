[ 문제 ]
'''
n × n 크기의 이차원 배열 arr이 매개변수로 주어질 때, 
arr이 다음을 만족하면 1을 아니라면 0을 return 하는 solution 함수를 작성해 주세요.
0 ≤ i, j < n인 정수 i, j에 대하여 arr[i][j] = arr[j][i]
arr	                                          result
[[5, 192, 33], [192, 72, 95], [33, 95, 999]]	1
'''
//=====================================================================

[ 내 풀이 ]
// flag 작성 방식을 처음 접하다!
class Solution {
    public int solution(int[][] arr) {
        int answer = 1;
        boolean ok = true;
        
        for(int i=0; i<arr.length; i++) {
            for(int j=0; j<arr[i].length; j++) { // 2차원 배열 길이 표현 확인
                if(arr[i][j] != arr[j][i]) {
                    answer = 0;
                    ok = false;
                    break;
                }
            }
            if (!ok) break;
        }
        
        return answer;
    }
}
//=====================================================================

[ 타 풀이 ]
import java.util.stream.IntStream;
class Solution {
    public int solution(int[][] arr) {
        return IntStream.range(0, arr.length) // 행의 개수만큼 int 생성 
                .allMatch(i -> IntStream.range(0, arr[0].length)
                        .allMatch(j -> arr[i][j] == arr[j][i])) ? 1 : 0;
    }
}
// 모든 i에 대해 -> 모든 j에 대해 -> arr[i][j] == arr[j][i]가 성립하느냐?
// 처음에 왜 allMatch가 두 번씩 필요하지 싶었는데 내 for문이랑 똑같은 거임. 각 i마다 모든 j를 다 매칭시켜 판단하는 거니까.
//=====================================================================

[ 메모 ]
1. 2차원 배열은 행열 길이를 각각 어떻게 지정하나?
  행: 1차원 때처럼 length 사용
  열: arr[행].length

2. 자바에 flag라는 로직이 있다. 보통 boolean으로 변수를 만들어 상태를 기록해둠.
  초기값은 일단 정상이라고 가정, 이후 문제 발견 시 false로 변경하는 식.

3. allMatch(): 스트림에 들어 있는 모든 요소가 조건을 만족하는지 확인하는 검사 메서드. true, false 반환.
               하나라도 false면 break처럼 즉시 중단함.
               이외에도 anyMatch(), noneMatch()도 있음.

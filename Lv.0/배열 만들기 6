[ 문제 ]
'''
0과 1로만 이루어진 정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk을 만드려고 합니다.
i의 초기값을 0으로 설정하고 i가 arr의 길이보다 작으면 다음을 반복합니다.
만약 stk이 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다.
stk에 원소가 있고, stk의 마지막 원소가 arr[i]와 같으면 stk의 마지막 원소를 stk에서 제거하고 i에 1을 더합니다.
stk에 원소가 있는데 stk의 마지막 원소가 arr[i]와 다르면 stk의 맨 마지막에 arr[i]를 추가하고 i에 1을 더합니다.
위 작업을 마친 후 만들어진 stk을 return 하는 solution 함수를 완성해 주세요.
단, 만약 빈 배열을 return 해야한다면 [-1]을 return 합니다.
'''
//=====================================================================

[ 내 풀이 ]
import java.util.*;
class Solution {
    public int[] solution(int[] arr) {
        List<Integer> stk = new ArrayList<>();
        
        for(int i=0; i<arr.length; i++) {
            // stk 길이가 0일 때
            if(stk.size() == 0)
                stk.add(arr[i]);
            // stk 원소가 arr과 같을 때
            else if(stk.get(stk.size()-1) == arr[i])
                stk.remove(stk.size()-1);
            // stk 원소가 arr과 다를 때
            else
                stk.add(arr[i]);
        }

        return (stk.size() == 0) ? new int[]{-1} : stk.stream().mapToInt(i->i).toArray();
    }
}
//=====================================================================

[ 타 풀이 ]
// 프로그래머스에선 Stack<Integer> stack=new Stack<>();을 썼지만 댓글에서 Deque를 쓰라길래 이건 뭐지 한참 자료구조를 찾아보게 된.
import java.util.Deque;
import java.util.ArrayDeque;
class Solution {
    public int[] solution(int[] arr) {
        Deque<Integer> stack = new ArrayDeque<>();

        for (int no : arr) {
            if (!stack.isEmpty() && no == stack.peek()) {
                stack.pop();
            } else {
                stack.push(no);
            }
        }

        return stack.isEmpty() ? new int[] { -1 } 
                               : stack.stream().mapToInt(i -> i).toArray();
    }
}

//=====================================================================

[ 메모 ]
1. 나는 Stack, Queue만 알고, 얘네의 부모나 확장형은 몰랐는데 이번에 정리해 보겠다.
  https://vanslog.io/posts/language/java/why-use-deque-instead-of-stack/
  일단 Vector의 자식이 Stack임. 내 노션에서도 썼었지만, Vector는 동기화된 메서드로 구성되어 있어 멀티 스레드 환경에서 안전하다는 점이 있었는데,
  자바 1.5 이후부터는 Collections.synchronizedList가 제공되면서 ArrayList를 써도 동기화가 가능해짐. 그래서 이젠 Vector도, Stack도 안 쓰임.

  그럼 Deque는 무엇인가. Double Ended Queue, 양방향 큐라 양쪽에서 삽입/삭제가 빠름. FIFO인 Queue 인터페이스를 상속함.
  Deque의 구현체가 ArrayDeque임.
  Deque<Integer> arrdeque = new ArrayDeque<>(); 또는 Queue<Integer> arrdeque = new ArrayDeque<>(); 둘 다 가능.
  근데 이 둘의 차이는 뭐지? 
  → Deque가 Queue의 상위호환임. Queue 인터페이스는 단방향 큐만 정의하므로 ArrayDeque의 push/pop 등의 스택 기능을 쓰지 못함.
  그래서 요즘 실무에서는 Deque를 더 많이 쓴다고.

2. 위 내용에 따르면 stack 기능을 쓰려면 Deque를 써야 한다는 건데, Queue에서의 값 삽입과 Stack에서의 값 삽입이 무슨 차이이길래?
  둘 다 동작은 '넣기'여도, 꺼낼 때의 순서가 완전히 반대라서 의미가 다름.
  같은 ArrayDeque라도
  Deque<Integer> d = new ArrayDeque<>();
  d.push(1); d.push(2); // pop 하면 2 -> 1 순서로 나옴.(LIFO)

  Queue<Integer> q = new ArrayDeque<>();
  q.offer(1);
  q.offer(2); // poll 하면 1 -> 2 순서로 나옴.(FIFO)
  따라서 이번 문제에서 마지막에 넣은 게 가장 먼저 삭제되어야 할 때가 있으니까 stack 기능을 갖고 있는 Deque를 써야 하는 것!

3. 이제껏 코테를 풀면서 구현체를 많이 써봤음. 근데 인터페이스와 구현체는 뭐가 다른 걸까.
  • 인터페이스: 기능(메서드) 목록만 적어둔 설계도. 즉, 선언만 있고 동작은 없음.
    Ex) List, Deque, Queue 등 
        public interface List<E> {
            void add(E e);
            E get(int index);
            int size(); ...
        }

  • 구현체(implementation): 인터페이스에 적힌 걸 실제로 어떻게 '동작'할지 코드로 만든 클래스.
    Ex) List 구현체=ArrayList,LinkedList,Vector / Deque 구현체=ArrayDeque, LinkedList

        Deque 인터페이스는 '양쪽에서 넣고 빼는 기능이 있어야 한다'고 선언함.
        ArrayDeque는 Deque가 정의한 그 기능들을 '배열' 방식으로 구현한 클래스.

  그렇다면 List<Integer> list = new List<>();라고 쓰면 왼쪽 List가 인터페이스, new 다음의 List는 구현체가 되는 걸까?
  답은 No. 인터페이스는 객체 생성이 불가능해 아예 컴파일 오류가 남.
  그래서 선언할 때 ArrayList 위치가 new 다음이었던 것.

[ 문제 ]
'''
0과 1로만 이루어진 정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk을 만드려고 합니다.
i의 초기값을 0으로 설정하고 i가 arr의 길이보다 작으면 다음을 반복합니다.
만약 stk이 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다.
stk에 원소가 있고, stk의 마지막 원소가 arr[i]와 같으면 stk의 마지막 원소를 stk에서 제거하고 i에 1을 더합니다.
stk에 원소가 있는데 stk의 마지막 원소가 arr[i]와 다르면 stk의 맨 마지막에 arr[i]를 추가하고 i에 1을 더합니다.
위 작업을 마친 후 만들어진 stk을 return 하는 solution 함수를 완성해 주세요.
단, 만약 빈 배열을 return 해야한다면 [-1]을 return 합니다.
'''
//=====================================================================

[ 내 풀이 ]
import java.util.*;
class Solution {
    public int[] solution(int[] arr) {
        List<Integer> stk = new ArrayList<>();
        
        for(int i=0; i<arr.length; i++) {
            // stk 길이가 0일 때
            if(stk.size() == 0)
                stk.add(arr[i]);
            // stk 원소가 arr과 같을 때
            else if(stk.get(stk.size()-1) == arr[i])
                stk.remove(stk.size()-1);
            // stk 원소가 arr과 다를 때
            else
                stk.add(arr[i]);
        }

        return (stk.size() == 0) ? new int[]{-1} : stk.stream().mapToInt(i->i).toArray();
    }
}
//=====================================================================

[ 타 풀이 ]
// 프로그래머스에선 Stack<Integer> stack=new Stack<>();을 썼지만 댓글에서 Deque를 쓰라길래 이건 뭐지 한참 자료구조를 찾아보게 된.
import java.util.Deque;
import java.util.ArrayDeque;
class Solution {
    public int[] solution(int[] arr) {
        Deque<Integer> stack = new ArrayDeque<>();

        for (int no : arr) {
            if (!stack.isEmpty() && no == stack.peek()) {
                stack.pop();
            } else {
                stack.push(no);
            }
        }

        return stack.isEmpty() ? new int[] { -1 } 
                               : stack.stream().mapToInt(i -> i).toArray();
    }
}

//=====================================================================

[ 메모 ]
1. 나는 Stack, Queue만 알고, 얘네의 부모나 확장형은 몰랐는데 이번에 정리해 보겠다.
  https://vanslog.io/posts/language/java/why-use-deque-instead-of-stack/
  일단 Vector의 자식이 Stack임. 내 노션에서도 썼었지만, Vector는 동기화된 메서드로 구성되어 있어 멀티 스레드 환경에서 안전하다는 점이 있었는데,
  자바 1.5 이후부터는 Collections.synchronizedList가 제공되면서 ArrayList를 써도 동기화가 가능해짐. 그래서 이젠 Vector도, Stack도 안 쓰임.

  그럼 Deque는 무엇인가. Double Ended Queue, 양방향 큐라 양쪽에서 삽입/삭제가 빠름. FIFO인 Queue 인터페이스를 상속함.
  Deque의 구현체가 ArrayDeque임.
  Deque<Integer> arrdeque = new ArrayDeque<>(); 또는 Queue<Integer> arrdeque = new ArrayDeque<>(); 둘 다 가능.
  근데 이 둘의 차이는 뭐지? 
  → Deque가 Queue의 상위호환임. Queue 인터페이스는 단방향 큐만 정의하므로 ArrayDeque의 push/pop 등의 스택 기능을 쓰지 못함.
  그래서 요즘 실무에서는 Deque를 더 많이 쓴다고.


2. 위 내용에 따르면 stack 기능을 쓰려면 Deque를 써야 한다는 건데, Queue에서의 값 삽입과 Stack에서의 값 삽입이 무슨 차이이길래?
  둘 다 동작은 '넣기'여도, 꺼낼 때의 순서가 완전히 반대라서 의미가 다름.
  같은 ArrayDeque라도
  Deque<Integer> d = new ArrayDeque<>();
  d.push(1); d.push(2); // pop 하면 2 -> 1 순서로 나옴.(LIFO)

  Queue<Integer> q = new ArrayDeque<>();
  q.offer(1);
  q.offer(2); // poll 하면 1 -> 2 순서로 나옴.(FIFO)
  따라서 이번 문제에서 마지막에 넣은 게 가장 먼저 삭제되어야 할 때가 있으니까 stack 기능을 갖고 있는 Deque를 써야 하는 것!


3. 이제껏 코테를 풀면서 구현체를 많이 써봤음. 근데 인터페이스와 구현체는 뭐가 다른 걸까.
  • 인터페이스: 기능(메서드) 목록만 적어둔 설계도. 즉, 선언만 있고 동작은 없음.
    Ex) List, Deque, Queue 등 
        public interface List<E> {
            void add(E e);
            E get(int index);
            int size(); ...
        }

  • 구현체(implementation): 인터페이스에 적힌 걸 실제로 어떻게 '동작'할지 코드로 만든 클래스.
    Ex) List 구현체=ArrayList,LinkedList,Vector / Deque 구현체=ArrayDeque, LinkedList, PriorityQueue

        Deque 인터페이스는 '양쪽에서 넣고 빼는 기능이 있어야 한다'고 선언함.
        ArrayDeque는 Deque가 정의한 그 기능들을 '배열 기반 deque'로 구현하겠다는 클래스.

  그렇다면 List<Integer> list = new List<>();라고 쓰면 왼쪽 List가 인터페이스, new 다음의 List는 구현체가 되는 걸까?
  답은 No. 인터페이스는 객체 생성이 불가능해 아예 컴파일 오류가 남.
  그래서 선언할 때 ArrayList 위치가 new 다음이었던 것.


4. 다른 문제 풀다 여기에 개념 추가가 필요할 것 같아 다시 옴.
    ※ 다형성: 타입 ≠ 실제 객체

    Animal a = new Dog(); // 업캐스팅 (Dog는 Animal의 자식이니 자동으로 형변환, (Animal) 안 써도 됨.)
    Dog d = (Dog) a; // 다운캐스팅
    a.eat();   // ✅ (Animal에 있음)
    a.bark();  // ❌ (Dog 전용 메서드)
    GPT가 들어준 예시인데, a가 사용 가능한 메서드가 Animal 기준이라고 하는 거임. 
    처음엔 헷갈렸는데 생각해보니 위 Deque, Queue 예시에서도 stack 메서드를 쓰려면 그걸 갖고 있는 Deque를 써야 한다고 했었음.
    즉, 쓸 수 있는 메서드 범위는 맨 앞에 나오는 변수 '타입'으로 결정되는 것. 그 메서드가 어떻게 동작하는지는 구현체로 결정됨.

    왜 굳이 이렇게 불편하게 쓰는 걸까. → 1. 인터페이스 중심 설계로 기능을 제한해 실수 방지 & 구현체 교체 쉬움 / 2. 타입 불일치 하면 컴파일러가 알려줘서 안정성

    그럼 Dog 전용 메서드는 어떻게 쓸 수 있나? 아래와 같이 다운캐스팅을 하거나, instanceof를 쓰거나, 처음부터 Dog 타입으로 받던가.
    1) Dog d = (Dog) a; d.bark();    
    2) if (a instanceof Dog) {
            ((Dog) a).bark();
        }
    3) Dog d = new Dog();

    어라, List<Integer> list = new List<>();은 에러라면서 왜 3번은 가능하지?
    여기에서 Dog는 인터페이스가 아니라 '클래스'이기 때문!
    class Animal {
        void eat() {}
    }
    
    class Dog extends Animal {
        @Override
        void eat() {// Animal에서 받은 eat() 메서드 수정 가능}
        void bark() {}
    }
    위에서 Dog 클래스를 구체 클래스라고 하는데, 구체 클래스는 객체 생성이 가능함.
    추가로 위 Dog 클래스에서 eat()을 재정의 하고 있으므로 Animal a = new Dog(); a.eat();을 실행하면 Dog의 eat()이 실행됨.
    (재정의 안 했으면(=오버라이딩이 없으면) 그냥 Animal의 eat()이 그대로 출력됨.)

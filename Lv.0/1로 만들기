[ 문제 ]
'''
정수가 있을 때, 짝수라면 반으로 나누고, 홀수라면 1을 뺀 뒤 반으로 나누면, 마지막엔 1이 됩니다. 
예를 들어 10이 있다면 다음과 같은 과정으로 1이 됩니다.
10 / 2 = 5
(5 - 1) / 2 = 2
2 / 2 = 1
위와 같이 3번의 나누기 연산으로 1이 되었습니다.
정수들이 담긴 리스트 num_list가 주어질 때, num_list의 모든 원소를 1로 만들기 위해서 필요한 나누기 연산의 횟수를 return하도록 solution 함수를 완성해주세요.
'''
//=====================================================================

[ 내 풀이 ]
class Solution {
    public int solution(int[] num_list) {
        int count = 0;
        
        for(int num : num_list) {
            while(num != 1) {
                if(num % 2 == 0)
                    num = num / 2; // 짝수
                else
                    num = (num - 1) / 2; // 홀수
                
                count++;
            }
        }
        return count;
    }
}
//=====================================================================

[ 타 풀이 1 ]
int answer = 0;
for(int i = 0;num_list.length>i;i++){
    while(num_list[i]!=1){
        num_list[i]/=2;
        answer++;
    }
}
return answer;
// 얼핏 보면 홀수값 처리가 없는 걸로 보이는데, 사실 다 포함된 계산임.
// 정수 나눗셈에서는 소수점이 생기면 '버림'!

[ 타 풀이 2 ]
return Arrays.stream(num_list).map(i -> Integer.toBinaryString(i).length() - 1).sum();

//=====================================================================

[ 메모 ]
1. toBinaryString(정수): 정수를 이진수 문자열로 바꿈. 2 -> "10" (길이=2)
  이진수에서의 길이의 의미는 '그 수를 표현하기 위해 필요한 비트 수'임.
  Integer.toBinaryString(i).length()까지가 이 내용.

  그럼 -1은 왜 한 걸까?
  이건 이진수의 '최고 자리 지수'를 구하는 것과 같다고 함. (최고 자리란 가장 왼쪽 비트 인덱스를 말함. 8이면 가장 왼쪽의 1은 2³ 자리)
  항상 '최고 자리 지수 = 이진수 자릿수 - 1'이 됨. (인덱스는 0부터 시작하니까, 그래서 length-1)
  
  어떤 수 i를 2로 몇 번 나누면 2이 되는지 
  = 2의 몇 제곱 자리인지 
  = 수학적으로 밑이 2인 로그의 내림값과 동일

  즉, 타 풀이 2는 각 요소마다의 최고 자리 지수를 구해 다 더한 것!
  복잡해 보였는데, 보다 보면 당연한 내용이다. 2의 배수마다 자릿수가 달라지는데 인덱스는 0부터 시작이니까 길이-1을 하여 최고 지수를 구한 것.
